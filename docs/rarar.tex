\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[ruled,vlined]{algorithm2e}
\SetKwComment{Comment}{/* }{ */}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\lstset{
  basicstyle=\ttfamily\scriptsize,
  breaklines=true,
  columns=flexible,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{gray},
  keywordstyle=\color{blue},
  stringstyle=\color{purple},
  showstringspaces=false,
  breakatwhitespace=true,
  breakindent=0pt
}

\begin{document}

\title{RARAR: Random Access to RAR Archives}

\author{\IEEEauthorblockN{Elias Benbourenane}
	\IEEEauthorblockA{\textit{School of Computing and Information} \\
		\textit{University of Pittsburgh}\\
		Pittsburgh, USA \\
		elb222@pitt.edu}
}

\maketitle

\begin{abstract}
	This paper presents RARAR (Random Access RAR)\footnote{Available at: https://github.com/eliasbenb/RARAR.py}, a Python library that enables efficient access to RAR archives without requiring complete downloads. Our implementation supports multiple source types (HTTP URLs, local files, and file-like objects) while achieving significant bandwidth reduction for remote archive access. We discuss the technical challenges of parsing RAR formats, detail our architecture, and demonstrate bandwidth savings exceeding 99\% compared to traditional approaches. While currently limited to uncompressed files, our framework provides a foundation for future development in random-access archive handling.
\end{abstract}

\begin{IEEEkeywords}
	random access, RAR archives, Python library, HTTP Range requests, bandwidth optimization, file extraction
\end{IEEEkeywords}

\section{Introduction}
File archiving remains a fundamental practice for efficiently distributing file collections, particularly in cloud environments where bandwidth and storage constraints are critical considerations. The RAR format, despite its proprietary nature, continues to see widespread adoption due to its robust compression capabilities and widespread tool support. However, traditional RAR handling approaches require downloading entire archives before accessing individual files—a significant limitation when working with large remote archives.

Random access to archive contents would provide substantial benefits across numerous applications:
\begin{itemize}
	\item Previewing archive contents without full downloads
	\item Extracting specific files from large archives
	\item Streaming media content stored within archives
	\item Enabling search engine indexing of archive contents
\end{itemize}

RARAR addresses this limitation by providing a Python package that implements random access to RAR archives. While supporting local files, in-memory buffers, and other file-like objects, the library emphasizes HTTP sources due to their significant practical benefits. Our implementation leverages HTTP Range requests to selectively retrieve file segments, dramatically reducing bandwidth requirements and improving access efficiency.

The RARAR library is available as open-source software on GitHub: \url{https://github.com/eliasbenb/RARAR.py}. This paper presents the design, implementation, and performance characteristics of the library.

\subsection{Problem Statement}
Current approaches to accessing remote archives exhibit substantial inefficiencies, particularly as archive sizes increase. Consider extracting a 100KB document from a 100GB remote archive—the conventional workflow requires:

\begin{enumerate}
	\item Downloading the entire 100GB archive
	\item Extracting the 100KB target file
	\item Discarding 99.9999\% of the downloaded data
\end{enumerate}

This approach suffers from several critical issues:
\begin{itemize}
	\item Excessive bandwidth consumption and associated costs
	\item Storage limitations on client devices
	\item Time delays during the download process
	\item Environmental impact due to unnecessary data transfer
\end{itemize}

\subsection{Contribution}
This paper makes the following contributions:
\begin{itemize}
	\item A comprehensive analysis of the RAR file format from a random-access perspective
	\item Development of a Python library enabling random access to RAR archives via multiple source types
	\item Implementation of an efficient RAR parsing algorithm
	\item Empirical evaluation of bandwidth-saving potential in HTTP-based RAR access with HTTP Range requests
\end{itemize}

\section{Related Work}
\subsection{Existing RAR Handling Libraries}
Several libraries provide RAR archive handling capabilities, though none are designed for random access:

\begin{itemize}
	\item \textbf{UnRAR}: The official C library from RARLAB provides extraction functionality but requires local access to complete archives.

	\item \textbf{Python-rarfile}: A Python module wrapping the UnRAR library or command-line tools. While feature-complete, it requires full archive availability before extraction.
\end{itemize}

\subsection{Random Access in Other Archive Formats}
Research on random access has primarily focused on formats other than RAR:

\begin{itemize}
	\item \textbf{ZIP}: The ZIP format inherently supports efficient random access through its central directory structure located at the file's end. Libraries like Python's \texttt{zipfile} can parse this directory without downloading the entire archive, though full file access remains necessary for extraction.

	\item \textbf{LZOP}: The LZOP format enables random access to compressed data blocks, as demonstrated by the lzopfs project\cite{b5}, allowing efficient extraction of specific files. However, LZOP lacks the widespread adoption of RAR or ZIP.
\end{itemize}

\subsection{HTTP Range Requests in Content Delivery}
HTTP Range requests have proven valuable in various content delivery scenarios such as video streaming and resumable downloads. These applications demonstrate how requesting specific byte ranges optimizes data transfer and reduces bandwidth waste.

Our work extends these techniques to RAR archive access. To our knowledge, RARAR represents the first implementation of HTTP-based random access for RAR archives.

\section{Technical Background}

\subsection{RAR File Format}
The RAR archive format, developed by Eugene Roshal and maintained by win.rar GmbH, uses a proprietary structure that has been partially reverse-engineered by the community. The format consists of sequential blocks:

\begin{enumerate}
	\item Marker block (RAR signature)
	\item Archive header block
	\item File header blocks (one per file)
	\item End of archive block
\end{enumerate}

Each block follows a consistent structure (Figure~\ref{fig:block_header}) with a header containing block type, size, and various flags.

\begin{figure}[htbp]
	\centerline{\includegraphics[width=\columnwidth]{fig/rar-block-header-diagram.png}}
	\caption{RAR Block Header Structure}
	\label{fig:block_header}
\end{figure}

\subsubsection{File Header Structure}
File headers are crucial for random access as they contain location and extraction information. The header extends the basic block structure with additional fields (Table~\ref{tab:file_header}), including file size, packed size, attributes, and filename—all essential for selective file access.

\begin{table}[htbp]
	\caption{RAR File Header Fields (after the basic header)}
	\begin{center}
		\footnotesize
		\begin{tabular}{|c|c|l|}
			\hline
			\textbf{Offset} & \textbf{Size} & \textbf{Description}                    \\
			\hline
			0x00            & 4 bytes       & Packed size (low part)                  \\
			\hline
			0x04            & 4 bytes       & Unpacked size (low part)                \\
			\hline
			0x08            & 1 byte        & Host OS (0=MS DOS, 1=OS/2, etc.)        \\
			\hline
			0x09            & 4 bytes       & File CRC32                              \\
			\hline
			0x0D            & 4 bytes       & File time (DOS format)                  \\
			\hline
			0x11            & 1 byte        & Unpacker version                        \\
			\hline
			0x12            & 1 byte        & Method (0x30=Store, 0x31=Fastest, etc.) \\
			\hline
			0x13            & 2 bytes       & Filename size                           \\
			\hline
			0x15            & 4 bytes       & File attributes                         \\
			\hline
			0x19            & Variable      & Optional high pack/unpack sizes         \\
			\hline
			                & Variable      & Filename (length from offset 0x13)      \\
			\hline
		\end{tabular}
		\label{tab:file_header}
	\end{center}
\end{table}

\subsection{HTTP Range Requests}
HTTP Range requests enable clients to request specific portions of resources, a capability essential for our implementation when working with remote archives. The protocol, defined in RFC 7233\cite{b3}, uses the Range header to specify byte ranges and responds with 206 Partial Content status.

\subsubsection{Range Request Specification}
The HTTP/1.1 protocol defines the Range header field in RFC 7233. A typical Range request header has the format:

\begin{lstlisting}
Range: bytes=start-end
\end{lstlisting}

Where \texttt{start} and \texttt{end} are byte positions. For example:
\begin{lstlisting}
Range: bytes=0-499    // First 500 bytes
Range: bytes=500-999  // Second 500 bytes
Range: bytes=-500     // Last 500 bytes
Range: bytes=500-     // All bytes from position 500
\end{lstlisting}

\subsubsection{Server Support Considerations}
Range request support varies across servers. Our implementation detects support through:
\begin{itemize}
	\item Confirming 206 or 200 response codes for range requests
	\item Checking for the \texttt{Accept-Ranges} header
	\item Validating requested and returned content lengths
\end{itemize}

\subsubsection{RAR Format Variations}
RAR has evolved through versions 1.3, 2.0, 3.0, 4.0, and 5.0, each introducing changes to header structures and compression algorithms. Our implementation targets the widely-adopted RAR 3.0 and 4.0 formats.

\subsubsection{Reverse Engineering Approach}
Without official documentation, our understanding derives from:
\begin{itemize}
	\item Analysis of open-source implementations
	\item Community-documented specifications
	\item Testing against sample archives
\end{itemize}

\section{Design and Implementation}

\subsection{Architecture Overview}
RARAR is designed around the principle of minimal data transfer principle, downloading only the bytes necessary to accomplish specific tasks. The library consists of three main components:

\begin{enumerate}
	\item \textbf{Source Handlers}: Abstractions for file-like objects, including HTTP sources, local files, and memory buffers
	\item \textbf{Version Handlers}: Factory pattern implementation for automatic RAR version detection
	\item \textbf{File Extractor}: Core logic for parsing headers and extracting files
\end{enumerate}

\subsubsection{Source Handler Abstraction}
Our adapter pattern enables archive access regardless of source type, maintaining separation between parsing logic and data access methods. Compatible sources must implement standard Python \texttt{io} module interfaces.

Required methods include:
\begin{itemize}
	\item \texttt{seek(position)}: Navigate to specific byte positions
	\item \texttt{read(size)}: Read specified byte counts from current position
\end{itemize}

\subsection{RAR Parsing Algorithms}
RARAR's core innovation lies in iterating through archives without downloading compressed content. The implementation parses only necessary headers while skipping file data, achieving substantial bandwidth reduction.

Algorithm~\ref{alg:parse_file_header} demonstrates our efficient header parsing approach. We initially read a 128-byte chunk containing most headers, performing additional reads only when necessary. This strategy minimizes network requests, particularly valuable for HTTP sources.

\begin{algorithm}[htb]
	\caption{Parsing File Headers}
	\label{alg:parse_file_header}
	\DontPrintSemicolon
	\KwIn{position in the file}
	\KwOut{file info object and next position}
	$headerChunk \gets ReadBytes(position, 128)$\;
	$headType, headFlags, headSize \gets ParseHeader(headerChunk[0:7])$\;
	\If{$headType \neq RAR3\_BLOCK\_FILE$}{
		\Return $null, position + headSize$\;
	}
	\If{$headSize > len(headerChunk)$}{
		$headerChunk \gets headerChunk + ReadBytes(position + 128, headSize - 128)$\;
	}
	$packSize, unpSize, method, fileCRC, nameSize \gets$\;
	$\qquad ParseFileFields(headerChunk[7:])$\;
	\If{$headFlags$ \& $FLAG\_HAS\_HIGH\_SIZE$}{
		$highPackSize, highUnpSize \gets ParseHighSizes(headerChunk)$\;
		$packSize \gets packSize + (highPackSize \ll 32)$\;
		$unpSize \gets unpSize + (highUnpSize \ll 32)$\;
	}
	$fileName \gets ParseFileName(headerChunk, nameSize, headFlags)$\;
	$isDirectory \gets (headFlags$ \& $FLAG\_DIRECTORY) = FLAG\_DIRECTORY$\;
	$dataOffset \gets position + headSize$\;
	$nextPos \gets dataOffset$\;
	\If{$headFlags$ \& $FLAG\_HAS\_DATA$}{
		$nextPos \gets nextPos + packSize$\;
	}
	$fileInfo \gets CreateFileInfo(fileName, unpSize, ...)$\;
	\Return $fileInfo, nextPos$\;
\end{algorithm}

\section{Performance Evaluation}

\subsection{Experimental Setup}
We evaluated RARAR using diverse archives under controlled conditions:

\begin{itemize}
	\item \textbf{Client}: Python 3.13 on Ubuntu 24.04
	\item \textbf{Server}: RClone WebDAV server on Ubuntu 24.04
	\item \textbf{Network}: 1Gbps LAN with simulated latency using clumsy
	\item \textbf{Test Archives}: RAR archives from 10MB to 50GB containing 10-250 files
\end{itemize}

\subsection{Bandwidth Usage}
RARAR demonstrates exceptional bandwidth efficiency. Table~\ref{tab:bandwidth_comparison} shows bandwidth savings across various archive sizes. The key finding is that bandwidth usage remains constant regardless of archive size, scaling linearly with file count at approximately 32KB per file due to our header-only parsing approach.

For a 50GB archive with 250 files, RARAR required only 7.82MB of data transfer—a 99.98\% reduction compared to traditional methods.

\begin{table}[htbp]
	\caption{Bandwidth Comparison: RARAR vs. Traditional Methods}
	\begin{center}
		\footnotesize
		\begin{tabular}{|c|c|c|c|}
			\hline
			\textbf{File Count} & \textbf{Archive Size} & \textbf{Bandwidth} & \textbf{Bandwidth Savings} \\
			\hline
			10                  & 10MB                  & 0.32MB             & 96.800\%                   \\
			\hline
			10                  & 100MB                 & 0.32MB             & 99.680\%                   \\
			\hline
			10                  & 1GB                   & 0.32MB             & 99.970\%                   \\
			\hline
			10                  & 10GB                  & 0.32MB             & 99.997\%                   \\
			\hline
			10                  & 50GB                  & 0.32MB             & 99.999\%                   \\
			\hline
			50                  & 10MB                  & 1.57MB             & 84.300\%                   \\
			\hline
			50                  & 100MB                 & 1.57MB             & 98.430\%                   \\
			\hline
			50                  & 1GB                   & 1.57MB             & 99.850\%                   \\
			\hline
			50                  & 10GB                  & 1.57MB             & 99.980\%                   \\
			\hline
			50                  & 50GB                  & 1.57MB             & 99.997\%                   \\
			\hline
			250                 & 10MB                  & 7.82MB             & 21.800\%                   \\
			\hline
			250                 & 100MB                 & 7.82MB             & 92.180\%                   \\
			\hline
			250                 & 1GB                   & 7.82MB             & 99.240\%                   \\
			\hline
			250                 & 10GB                  & 7.82MB             & 99.920\%                   \\
			\hline
			250                 & 50GB                  & 7.82MB             & 99.980\%                   \\
			\hline
		\end{tabular}
		\label{tab:bandwidth_comparison}
	\end{center}
\end{table}

\subsection{Operation Latency}
Operation latency depends primarily on network conditions due to multiple small HTTP requests. Table~\ref{tab:network_impact} shows performance under various network latencies. Listing 250 files takes 411ms at 1ms latency but increases to 33,961ms at 100ms latency.

To mitigate latency impact, we implemented:
\begin{itemize}
	\item Batch reading of adjacent headers
	\item Predictive prefetching for likely-needed blocks
	\item Dynamic chunk sizing based on network conditions
\end{itemize}

\begin{table}[htbp]
	\caption{Network Condition Impact on RARAR Performance}
	\begin{center}
		\footnotesize
		\begin{tabular}{|c|c|c|}
			\hline
			\textbf{Latency} & \textbf{Number of Files} & \textbf{Time to List} \\
			\hline
			1ms              & 10                       & 46ms                  \\
			\hline
			1ms              & 50                       & 102ms                 \\
			\hline
			1ms              & 250                      & 411ms                 \\
			\hline
			50ms             & 10                       & 1,587ms               \\
			\hline
			50ms             & 50                       & 5,089ms               \\
			\hline
			50ms             & 250                      & 22,636ms              \\
			\hline
			100ms            & 10                       & 2,374ms               \\
			\hline
			100ms            & 50                       & 7,639ms               \\
			\hline
			100ms            & 250                      & 33,961ms              \\
			\hline
		\end{tabular}
		\label{tab:network_impact}
	\end{center}
\end{table}

\subsection{Scalability Analysis}
Our analysis demonstrates excellent scalability characteristics. Bandwidth usage remains constant regardless of archive size (Table~\ref{tab:bandwidth_comparison}), while operation latency scales linearly with file count (Table~\ref{tab:network_impact}). This enables efficient handling of arbitrarily large archives containing numerous files.

\section{Limitations and Future Work}

\subsection{Current Limitations}
Despite its advantages, RARAR currently has several limitations:

\begin{enumerate}
	\item \textbf{Compression Support}: Only uncompressed ("Store") files are supported. Files using RAR's compression algorithms cannot be extracted without downloading compressed blocks and implementing decompression.

	\item \textbf{Server Requirements}: Remote servers must support HTTP Range requests for RARAR to function correctly.

	\item \textbf{Multi-Part Archives}: Archives split across multiple files are not yet supported.

	\item \textbf{Encrypted Archives}: Password-protected archives cannot be processed due to the need to decrypt the entire archive structure.
\end{enumerate}

\subsection{Future Work}
Several promising extensions exist:

\subsubsection{Compressed File Support}
Implementing support for common RAR compression methods would significantly enhance utility. This requires:
\begin{itemize}
	\item Integration of RAR decompression algorithms
	\item Analysis of partial decompression feasibility
	\item Optimization of compressed data retrieval
\end{itemize}

A promising approach involves developing partial decompression strategies that identify and download only necessary compressed blocks before performing targeted decompression.

\subsubsection{RAR5 Support}
Supporting RAR5 would extend versatility by accommodating the latest format version. Our extensible factory pattern facilitates adding new version handlers while maintaining compatibility with existing formats.

\subsubsection{Server Integration}
Integrating RARAR into web servers could enable efficient file serving through:
\begin{itemize}
	\item Server-side random access capabilities
	\item Client-specific file range requests
	\item On-the-fly decompression and extraction
\end{itemize}

\section{Conclusion}
RARAR represents a novel approach to working with RAR archives. By combining careful format parsing with HTTP Range requests, our solution enables efficient file listing and extraction without full archive downloads.

The demonstrated bandwidth savings when accessing a 50GB archive while transferring only 0.32MB highlight significant efficiency improvements. Although currently limited to uncompressed files, RARAR establishes a foundation for comprehensive random-access archive handling.

This work provides both practical tools for developers and demonstrates techniques applicable to other archive formats, advancing the state of remote file access optimization.

\begin{thebibliography}{00}
	\bibitem{b1} E. Benbourenane, "RARAR.py: Random Access RAR," GitHub repository, Available: https://github.com/eliasbenb/RARAR.py, 2025.
	\bibitem{b2} E. Roshal, "RAR archive file format," Technical Specification, RARLAB, 2019.
	\bibitem{b3} R. Fielding et al., "Hypertext Transfer Protocol (HTTP/1.1): Range Requests," RFC 7233, Internet Engineering Task Force, June 2014.
	\bibitem{b4} Python Software Foundation, "io — Core tools for working with streams," Python Documentation, version 3.13, 2024.
	\bibitem{b5} D. Vasilevsky, "lzopfs: A FUSE filesystem for transparent random access to compressed LZOP archives," GitHub repository, Available: https://github.com/vasi/lzopfs, 2011.
\end{thebibliography}

\end{document}